// Exploit profiles for 3‑bet trainer (100bb cash, preflop)
// Focused on opener tendencies; applies to base 3‑bet raise/call maps.
// Output maps are clamped 0..100.

function clamp01(x) { return Math.max(0, Math.min(100, x)); }
function copyMap(m) { return Object.assign({}, m || {}); }

function tag(k) {
  if (!k || typeof k !== "string") return {};
  const s = k.endsWith("s"), o = k.endsWith("o"), p = k.length === 2 && k[0] === k[1];
  const hi = k[0], lo = p ? k[1] : k[1];
  const bw = ["A","K","Q","J","T"].includes(hi) && ["A","K","Q","J","T"].includes(lo);
  const wheel = hi === "A" && ["2","3","4","5"].includes(lo);
  const sc = s && !p && "AKQJT98765432".includes(hi) && "AKQJT98765432".includes(lo) &&
             Math.abs("AKQJT98765432".indexOf(hi) - "AKQJT98765432".indexOf(lo)) === 1;
  return { s, o, p, bw, wheel, sc };
}

function mapBump(m, pred, mul) {
  const out = copyMap(m);
  for (const k in out) if (pred(k, tag(k))) out[k] = clamp01(out[k] * mul);
  return out;
}
function mapFloor(m, pred, minPct) {
  const out = copyMap(m);
  for (const k in out) if (pred(k, tag(k))) out[k] = Math.max(out[k], minPct);
  return out;
}
function mapZero(m, pred) {
  const out = copyMap(m);
  for (const k in out) if (pred(k, tag(k))) out[k] = 0;
  return out;
}

// New profiles tuned for a 3‑bet trainer (opener’s leaks):
// - WIDE_OPEN_LP: opener too loose from late positions
// - TIGHT_OPEN_EP: opener too tight from early positions
// - OVERFOLD_3B: opener overfolds vs 3‑bets
// - UNDERFOLD_3B: opener under‑folds vs 3‑bets (i.e., defends too much)
// - HIGH_4BET_EP: opener 4‑bets too often from EP (we tighten bluffs, push value)
// - CALL_HEAVY_IP: opener over‑calls IP vs 3‑bets (we reduce bluffs OOP, value up)

const PROFILES = [
  {
    id: "WIDE_OPEN_LP",
    label: "Wide LP opens",
    describe: "Opener too loose from CO/BTN; widen linear 3‑betting and some suited bluffs IP.",
    adjust({ hero, villain, raiseMap, callMap }) {
      const late = ["CO","BTN"];
      let r = raiseMap, c = callMap;
      if (late.includes(villain)) {
        // More linear value and some suited bluffing IP
        r = mapFloor(r, (k, t) => (t.bw && t.o) || (t.s && (t.sc || t.bw)), 35);
        if (["BTN","CO","HJ"].includes(hero)) c = mapFloor(c, (k, t) => t.bw || t.p || t.sc, 100);
      }
      return { raiseMap: r, callMap: c };
    }
  },
  {
    id: "TIGHT_OPEN_EP",
    label: "Tight EP opens",
    describe: "Opener too tight from EP; reduce bluffs, push value 3‑bets, flats rarer EP vs EP.",
    adjust({ hero, villain, raiseMap, callMap }) {
      const early = ["UTG","UTG1","MP","HJ"];
      let r = raiseMap, c = callMap;
      if (early.includes(villain)) {
        r = mapBump(r, (k, t) => t.wheel || (t.s && !t.bw && !t.sc), 0.7);
        r = mapFloor(r, (k, t) => t.p && ["T","J","Q","K","A"].includes(k[0]), 100);
        const epEp = early.includes(hero);
        if (epEp) c = mapBump(c, () => true, 0.5);
      }
      return { raiseMap: r, callMap: c };
    }
  },
  {
    id: "OVERFOLD_3B",
    label: "Overfolds vs 3‑bets",
    describe: "Add Ax-suited and suited connector bluffs; value holds.",
    adjust({ raiseMap, callMap }) {
      let r = raiseMap;
      r = mapFloor(r, (k, t) => t.wheel && t.s, 45);
      r = mapFloor(r, (k, t) => t.s && t.sc, 40);
      return { raiseMap: r, callMap };
    }
  },
  {
    id: "UNDERFOLD_3B",
    label: "Under‑folds vs 3‑bets",
    describe: "Trim bluffs; keep or increase value 3‑betting.",
    adjust({ raiseMap, callMap }) {
      let r = raiseMap;
      r = mapBump(r, (k, t) => t.wheel || (t.s && !t.bw && !t.sc), 0.6); // fewer low‑equity bluffs
      r = mapFloor(r, (k, t) => t.p && ["T","J","Q","K","A"].includes(k[0]), 100);
      return { raiseMap: r, callMap };
    }
  },
  {
    id: "HIGH_4BET_EP",
    label: "High 4‑bet EP",
    describe: "Opener 4‑bets often from EP; reduce light bluffs, keep strong value.",
    adjust({ villain, raiseMap, callMap }) {
      const ep = ["UTG","UTG1","MP","HJ"].includes(villain);
      let r = raiseMap;
      if (ep) {
        r = mapBump(r, (k, t) => t.wheel || (t.s && !t.bw && !t.sc), 0.65);
        r = mapFloor(r, (k, t) => t.p && ["J","Q","K","A"].includes(k[0]), 100);
      }
      return { raiseMap: r, callMap };
    }
  },
  {
    id: "CALL_HEAVY_IP",
    label: "IP over‑calls",
    describe: "Opener over‑calls in position vs 3‑bets; value up OOP, trim bluffs OOP.",
    adjust({ hero, raiseMap, callMap }) {
      const oop = ["SB","BB","UTG","UTG1","MP"].includes(hero);
      let r = raiseMap, c = callMap;
      if (oop) {
        r = mapBump(r, (k, t) => t.wheel || (t.s && !t.bw && !t.sc), 0.75);
        r = mapFloor(r, (k, t) => t.p && ["T","J","Q","K","A"].includes(k[0]), 100);
      } else {
        // IP can keep some calls
        c = mapFloor(c, (k, t) => t.bw || t.p || t.sc, 100);
      }
      return { raiseMap: r, callMap: c };
    }
  }
];

export function getExploitProfile(id) {
  return PROFILES.find(p => p.id === id) || null;
}

export function adjustRanges({ table, hero, villain, raiseMap, callMap, profileId }) {
  const pf = getExploitProfile(profileId);
  if (!pf) return { raiseMap, callMap };
  let r = copyMap(raiseMap), c = copyMap(callMap);
  ({ raiseMap: r, callMap: c } = pf.adjust({ table, hero, villain, raiseMap: r, callMap: c }));
  for (const k in r) r[k] = clamp01(r[k]);
  for (const k in c) c[k] = clamp01(c[k]);
  return { raiseMap: r, callMap: c };
}

export const EXPLOIT_PROFILES = PROFILES.map(p => ({ id: p.id, label: p.label, describe: p.describe }));
